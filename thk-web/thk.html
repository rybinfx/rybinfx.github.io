<!DOCTYPE html>
<html lang="en">
<head>    
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>THK Sync</title>
  <style>
    html, body, div, canvas {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas {
      display: block;
    }
    .go {
      background-color: #ffffff19;
      border-radius: 64px;
      border: 1.0px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.747);
      
      position: absolute;
      bottom: 5%; left: 50%;
      transform: translateX(-50%);
      padding: 16px 26px;
      font-size: 20px;
      z-index: 10;
    }
    
    .go:active {
      background-color: white;
      color: black;
    }
    /* Centered div styling */
    #centeredText {
      color: rgba(255, 255, 255, 1.0);
      position: absolute;
      bottom: 55%; left: 50%;
      transform: translateX(-50%) translateY(50%);
      padding: 16px 26px;
      font-size: 28px;
      z-index: 10;
      text-align: center;
      transition: opacity 1s;
      opacity: 0.0;
      pointer-events: none;
    }

  </style>
</head>
<body>
  <div>
    <span id="centeredText">Entity sent to THK tower</span>
    <canvas id="lighthouse_canvas"></canvas>
    <button id="goButton" class="go">
      GO
    </button>
  </div>

  <script src="twgl.min.js"></script>
  <script src="thk.js"></script>


  <script>
    function showText() {
        const centeredText = document.getElementById("centeredText");
        centeredText.style.opacity = 1.0; // Show the text

        setTimeout(() => {
          centeredText.style.opacity = 0.0; // Hide the text after 3 seconds
        }, 3000); // 3000ms = 3 seconds
    }


    const lighthouse_canvas = document.getElementById("lighthouse_canvas");

    function resizeCanvas() {
      lighthouse_canvas.width = window.innerWidth;
      lighthouse_canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();

    // Initialize your canvas content after resizing
    const params = {
      seed: 0,
      val1: Math.random()*100.0,
      val2: Math.random()*100.0,
      valid: 0,
    }
    // params.seed = Math.random();

    
    const goButton = document.getElementById("goButton");
    goButton.addEventListener("click", function () {
      const jsonData = params;
      fetch('https://thk-tower.glitch.me/send-json', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
          },
          body: JSON.stringify(jsonData),
      })
      .then(response => response.json())
      .then(data => { console.log('Success:', data); showText(); })
      .catch((error) => {
          console.error('Error:', error);
      });


    });

    // Variables to store the previous position
    let prevX = 0;
    let prevY = 0;
    let isDragging = false;
    let velX = 0;
    let velY = 0;
    const callback = function(frame) {
      if (!isDragging) {
        let damp = 0.9;
        velX *= damp;
        velY *= damp;
        params.val1 += velX;
        params.val2 += velY;
      } else {
        velX *= 0.0;
        velY *= 0.0;
      }
      // console.log(velY);
    }
    lighthouse_generate(lighthouse_canvas, params, callback);


    function getPointerPosition(event) {
      let x, y;

      if (event.type.startsWith('touch')) {
        // Touch event
        const touch = event.touches[0] || event.changedTouches[0];
        x = touch.clientX;
        y = touch.clientY;
      } else {
        // Mouse event
        x = event.clientX;
        y = event.clientY;
      }

      // Adjust for canvas position
      const rect = lighthouse_canvas.getBoundingClientRect();
      x -= rect.left;
      y -= rect.top;

      return { x, y };
    }

    function handleStart(event) {
      event.preventDefault();
      isDragging = true;

      const pos = getPointerPosition(event);
      prevX = pos.x;
      prevY = pos.y;
      velX = 0;
      velY = 0;

      // params.seed = Math.random();
    }

    function handleMove(event) {
      if (!isDragging) return;
      event.preventDefault();

      const pos = getPointerPosition(event);
      const currentX = pos.x;
      const currentY = pos.y;

      let dx = currentX - prevX;
      let dy = currentY - prevY;

      prevX = currentX;
      prevY = currentY;

      dx = dx / lighthouse_canvas.height;
      dy = dy / lighthouse_canvas.height;

      dx = dx * -1.0;
      dy = dy * -1.0;

      params.val1 += dx*0.25;
      params.val2 += dy*0.5;

      velX = dx;
      velY = dy;


      // params.val1 += dx;
      // params.val2 += -dy;

    }

    function handleEnd(event) {
      if (!isDragging) return;
      event.preventDefault();
      isDragging = false;
    }

    // Add event listeners for mouse and touch events
    lighthouse_canvas.addEventListener('mousedown', handleStart, false);
    lighthouse_canvas.addEventListener('mousemove', handleMove, false);
    lighthouse_canvas.addEventListener('mouseup', handleEnd, false);
    lighthouse_canvas.addEventListener('mouseleave', handleEnd, false);

    lighthouse_canvas.addEventListener('touchstart', handleStart, false);
    lighthouse_canvas.addEventListener('touchmove', handleMove, false);
    lighthouse_canvas.addEventListener('touchend', handleEnd, false);
    lighthouse_canvas.addEventListener('touchcancel', handleEnd, false);
  </script>



</body>
</html>