var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/media-codecs/src/vp.js
var vp_exports = {};
__export(vp_exports, {
  VP_BIT_DEPTH: () => VP_BIT_DEPTH,
  VP_CODECS: () => VP_CODECS,
  VP_LEVELS: () => VP_LEVELS,
  VP_PROFILES: () => VP_PROFILES,
  formatCodec: () => formatCodec,
  formatLevel: () => formatLevel,
  getAllItems: () => getAllItems,
  getCodec: () => getCodec,
  getCodecName: () => getCodecName
});
var VP_CODECS = [
  { name: "VP8", cccc: "vp08" },
  { name: "VP9", cccc: "vp09" }
  // { name: "VP10", cccc: "vp10" },
];
var VP_PROFILES = [0, 1, 2, 3];
var VP_LEVELS = [
  "1",
  "1.1",
  "2",
  "2.1",
  "3",
  "3.1",
  "4",
  "4.1",
  "5",
  "5.1",
  "5.2",
  "6",
  "6.1",
  "6.2"
];
var VP_BIT_DEPTH = [8, 10, 12];
var formatProfile = (profile) => String(profile).padStart(2, "0");
var formatLevel = (level) => String(parseFloat(level) * 10).padStart(2, "0");
var formatBitDepth = (bitDepth) => String(bitDepth).padStart(2, "0");
var formatCodec = (cccc3, PP, LL, DD) => `${cccc3}.${PP}.${LL}.${DD}`;
var getAllItems = () => VP_CODECS.map(
  (codec) => VP_PROFILES.map(
    (profile) => VP_LEVELS.map(
      (level) => VP_BIT_DEPTH.map((bitDepth) => ({
        name: `${codec.name} Profile ${profile} Level ${level} BitDepth ${bitDepth}`,
        codec: formatCodec(
          codec.cccc,
          formatProfile(profile),
          formatLevel(level),
          formatBitDepth(bitDepth)
        )
      }))
    )
  )
).flat(4);
var getCodec = ({ name, profile, level, bitDepth }) => {
  const codec = VP_CODECS.find((codec2) => codec2.name === name);
  if (!codec) throw new Error(`Unknown VP Codec "${name}"`);
  if (!VP_PROFILES.includes(profile)) {
    throw new Error(`Unknown VP Profile "${profile}"`);
  }
  if (!VP_LEVELS.includes(level)) {
    throw new Error(`Unknown VP Level "${level}"`);
  }
  if (!VP_BIT_DEPTH.includes(bitDepth)) {
    throw new Error(`Unknown VP BitDepth "${bitDepth}"`);
  }
  return formatCodec(
    codec.cccc,
    formatProfile(profile),
    formatLevel(level),
    formatBitDepth(bitDepth)
  );
};
var getCodecName = (codec) => {
  var _a;
  return (_a = getAllItems().find((item) => item.codec === codec)) == null ? void 0 : _a.name;
};

// node_modules/media-codecs/src/av.js
var av_exports = {};
__export(av_exports, {
  AV_BIT_DEPTH: () => AV_BIT_DEPTH,
  AV_CODECS: () => AV_CODECS,
  AV_LEVELS: () => AV_LEVELS,
  AV_PROFILES: () => AV_PROFILES,
  AV_TIER: () => AV_TIER,
  formatCodec: () => formatCodec2,
  formatLevel: () => formatLevel2,
  getAllItems: () => getAllItems2,
  getCodec: () => getCodec2,
  getCodecName: () => getCodecName2
});
var AV_CODECS = [
  { name: "AV1", cccc: "av01" }
  // { name: "AV2", cccc: "av02" },
];
var AV_PROFILES = [
  { name: "Main", P: "0" },
  { name: "High", P: "1" },
  { name: "Professional", P: "2" }
];
var AV_LEVELS = [
  "2.0",
  "2.1",
  "2.2",
  "2.3",
  "3.0",
  "3.1",
  "3.2",
  "3.3",
  "4.0",
  "4.1",
  "4.2",
  "4.3",
  "5.0",
  "5.1",
  "5.2",
  "5.3",
  "6.0",
  "6.1",
  "6.2",
  "6.3",
  "7.0",
  "7.1",
  "7.2",
  "7.3"
];
var AV_TIER = ["Main", "High"];
var AV_BIT_DEPTH = [8, 10, 12];
var formatProfile2 = ({ P }) => P;
var convertLevel = (level) => {
  const [X, Y] = level.split(".");
  return (parseInt(X, 10) - 2) * 4 + parseInt(Y, 10);
};
var formatLevel2 = (level) => String(convertLevel(level)).padStart(2, "0");
var formatTier = (tier) => tier.at(0);
var formatBitDepth2 = (bitDepth) => String(bitDepth).padStart(2, "0");
var formatCodec2 = (cccc3, P, LL, T, DD) => `${cccc3}.${P}.${LL}${T}.${DD}`;
var getAllItems2 = () => AV_CODECS.map(
  (codec) => AV_PROFILES.map(
    (profile) => AV_LEVELS.map(
      (level) => AV_TIER.map((tier) => {
        if (tier === "High" && convertLevel(level) < 8) return;
        return AV_BIT_DEPTH.map((bitDepth) => {
          if (profile.P !== "2" && bitDepth === 12) return;
          return {
            name: `${codec.name} ${profile.name} Profile Level ${level} Tier ${tier} BitDepth ${bitDepth}`,
            codec: formatCodec2(
              codec.cccc,
              formatProfile2(profile),
              formatLevel2(level),
              formatTier(tier),
              formatBitDepth2(bitDepth)
            )
          };
        });
      })
    )
  )
).flat(4).filter(Boolean);
var getCodec2 = ({ name, profile: profileName, level, tier, bitDepth }) => {
  const codec = AV_CODECS.find((codec2) => codec2.name === name);
  if (!codec) throw new Error(`Unknown AV Codec "${name}"`);
  const profile = AV_PROFILES.find((profile2) => profile2.name === profileName);
  if (!AV_PROFILES) {
    throw new Error(`Unknown AV Profile "${profileName}"`);
  }
  if (!AV_LEVELS.includes(level)) {
    throw new Error(`Unknown AV Level "${level}"`);
  }
  if (!AV_TIER.includes(tier)) {
    throw new Error(`Unknown AV Tier "${tier}"`);
  }
  if (!AV_BIT_DEPTH.includes(bitDepth)) {
    throw new Error(`Unknown AV BitDepth "${bitDepth}"`);
  }
  return formatCodec2(
    codec.cccc,
    formatProfile2(profile),
    formatLevel2(level),
    formatTier(tier),
    formatBitDepth2(bitDepth)
  );
};
var getCodecName2 = (codec) => {
  var _a;
  return (_a = getAllItems2().find((item) => item.codec === codec)) == null ? void 0 : _a.name;
};

// node_modules/media-codecs/src/avc.js
var avc_exports = {};
__export(avc_exports, {
  AVC_LEVELS: () => AVC_LEVELS,
  AVC_PROFILES: () => AVC_PROFILES,
  formatCodec: () => formatCodec3,
  formatLevel: () => formatLevel3,
  getAllItems: () => getAllItems3,
  getCodec: () => getCodec3,
  getCodecName: () => getCodecName3
});
var AVC_PROFILES = [
  { name: "Constrained Baseline", PP: "42", CC: "40" },
  { name: "Baseline", PP: "42", CC: "00" },
  { name: "Extended", PP: "58", CC: "00" },
  { name: "Main", PP: "4d", CC: "00" },
  { name: "High", PP: "64", CC: "00" },
  { name: "Progressive High", PP: "64", CC: "08" },
  { name: "Constrained High", PP: "64", CC: "0c" },
  { name: "High 10", PP: "6e", CC: "00" },
  { name: "High 4:2:2", PP: "7a", CC: "00" },
  { name: "High 4:4:4 Predictive", PP: "f4", CC: "00" },
  { name: "High 10 Intra", PP: "6e", CC: "10" },
  { name: "High 4:2:2 Intra", PP: "7a", CC: "10" },
  { name: "High 4:4:4 Intra", PP: "f4", CC: "10" },
  { name: "CAVLC 4:4:4 Intra", PP: "44", CC: "00" },
  { name: "Scalable Baseline", PP: "53", CC: "00" },
  { name: "Scalable Constrained Baseline", PP: "53", CC: "04" },
  { name: "Scalable High", PP: "56", CC: "00" },
  { name: "Scalable Constrained High", PP: "56", CC: "04" },
  { name: "Scalable High Intra", PP: "56", CC: "20" },
  { name: "Stereo High", PP: "80", CC: "00" },
  { name: "Multiview High", PP: "76", CC: "00" },
  { name: "Multiview Depth High", PP: "8a", CC: "00" }
];
var cccc = "avc1";
var AVC_LEVELS = [
  "1",
  "1.1",
  "1.2",
  "1.3",
  "2",
  "2.1",
  "2.2",
  "3",
  "3.1",
  "3.2",
  "4",
  "4.1",
  "4.2",
  "5",
  "5.1",
  "5.2",
  "6",
  "6.1",
  "6.2"
];
var formatLevel3 = (level) => (parseFloat(level) * 10).toString(16).padStart(2, "0");
var formatCodec3 = (cccc3, { PP, CC }, LL) => `${cccc3}.${PP}${CC}${LL}`;
var getAllItems3 = () => AVC_PROFILES.map(
  (profile) => AVC_LEVELS.map((level) => ({
    name: `AVC ${profile.name} Profile Level ${level}`,
    codec: formatCodec3(cccc, profile, formatLevel3(level))
  }))
).flat();
var getCodec3 = ({ profile: profileName, level }) => {
  if (!AVC_LEVELS.includes(level))
    throw new Error(`Unknown AVC Level "${level}"`);
  const profile = AVC_PROFILES.find((profile2) => profile2.name === profileName);
  if (!profile) throw new Error(`Unknown AVC Profile "${profileName}"`);
  return formatCodec3(cccc, profile, formatLevel3(level));
};
var getCodecName3 = (codec) => {
  var _a;
  return (_a = getAllItems3().find((item) => item.codec === codec)) == null ? void 0 : _a.name;
};

// node_modules/media-codecs/src/hevc.js
var hevc_exports = {};
__export(hevc_exports, {
  HEVC_LEVELS: () => HEVC_LEVELS,
  HEVC_PROFILES: () => HEVC_PROFILES,
  HEVC_PROFILE_COMPATIBILITY: () => HEVC_PROFILE_COMPATIBILITY,
  HEVC_TIER: () => HEVC_TIER,
  formatCodec: () => formatCodec4,
  formatLevel: () => formatLevel4,
  getAllItems: () => getAllItems4,
  getCodec: () => getCodec4,
  getCodecName: () => getCodecName4
});
var HEVC_PROFILES = [
  { name: "Main", PP: "1" },
  { name: "Main 10", PP: "2" },
  { name: "Main Still Picture", PP: "3" },
  // Version 2
  { name: "Range Extensions", PP: "4" },
  { name: "High Throughput", PP: "5" },
  { name: "Multiview Main", PP: "6" },
  { name: "Scalable Main", PP: "7" },
  // Version 3
  { name: "3D Main", PP: "8" },
  { name: "Screen Extended", PP: "9" },
  { name: "Scalable Range Extensions", PP: "10" },
  { name: "High Throughput Screen Extended", PP: "11" }
];
var cccc2 = "hev1";
var HEVC_PROFILE_COMPATIBILITY = Array.from({ length: 32 }, (_, i) => i);
var HEVC_LEVELS = [
  "1",
  "2",
  "2.1",
  "3",
  "3.1",
  "4",
  "4.1",
  "5",
  "5.1",
  "5.2",
  "6",
  "6.1",
  "6.2"
];
var HEVC_TIER = ["Main", "High"];
var convertLevel2 = (level) => parseFloat(level) * 10 * 3;
var formatLevel4 = (level) => String(convertLevel2(level));
var formatCompatibility = (compatibility) => compatibility.toString(16);
var formatTier2 = (tier) => tier === "Main" ? "L" : "H";
var formatCodec4 = (cccc3, { PP }, C, T, LL, CC) => `${cccc3}.${PP}.${C}.${T}${LL}.${CC}`;
var getAllItems4 = () => HEVC_PROFILES.map(
  (profile) => HEVC_PROFILE_COMPATIBILITY.map(
    (compatibility) => HEVC_LEVELS.map(
      (level) => HEVC_TIER.map((tier) => {
        if (tier === "High" && convertLevel2(level) < 120) return;
        return {
          name: `HEVC ${profile.name} Profile Compability ${compatibility} Level ${level} Tier ${tier}`,
          codec: formatCodec4(
            cccc2,
            profile,
            formatCompatibility(compatibility),
            formatTier2(tier),
            formatLevel4(level),
            "b0"
            // TODO
          )
        };
      })
    )
  )
).flat(3).filter(Boolean);
var getCodec4 = ({
  profile: profileName,
  compatibility,
  level,
  tier,
  constraint = "b0"
}) => {
  const profile = HEVC_PROFILES.find((profile2) => profile2.name === profileName);
  if (!profile) throw new Error(`Unknown HEVC profile "${profileName}"`);
  if (!HEVC_LEVELS.includes(level)) {
    throw new Error(`Unknown HEVC Level "${level}"`);
  }
  if (!HEVC_TIER.includes(tier)) {
    throw new Error(`Unknown HEVC Tier "${tier}"`);
  }
  return formatCodec4(
    cccc2,
    profile,
    formatCompatibility(compatibility),
    formatLevel4(level),
    formatTier2(tier),
    constraint
  );
};
var getCodecName4 = (codec) => {
  var _a;
  return (_a = getAllItems4().find((item) => item.codec === codec)) == null ? void 0 : _a.name;
};

export {
  __commonJS,
  __export,
  __toESM,
  __publicField,
  __privateGet,
  __privateAdd,
  __privateSet,
  __privateMethod,
  vp_exports,
  av_exports,
  avc_exports,
  hevc_exports
};
//# sourceMappingURL=chunk-Z2LGHYQB.js.map
