/**
 * A callback to notify on the status change. To compare with RecorderStatus enum values.
 */
export type onStatusChangeCb = (RecorderStatus: number) => any;
/**
 * Options for recording. All optional.
 */
export type RecorderOptions = {
    /**
     * A name for the recorder, used as prefix for the default file name.
     */
    name?: string;
    /**
     * The recording duration in seconds. If set to Infinity, `await canvasRecorder.stop()` needs to be called manually.
     */
    duration?: number;
    /**
     * The frame rate in frame per seconds. Use `await canvasRecorder.step();` to go to the next frame.
     */
    frameRate?: number;
    /**
     * Automatically download the recording when duration is reached or when `await canvasRecorder.stop()` is manually called.
     */
    download?: boolean;
    /**
     * Default file extension: infers which Encoder is selected.
     */
    extension?: string;
    /**
     * Default writing target: in-browser or file-system when available.
     */
    target?: string;
    /**
     * A specific encoder. Default encoder based on options.extension: GIF > WebCodecs > H264MP4.
     */
    encoder?: object;
    /**
     * See `src/encoders` or individual packages for a list of options.
     */
    encoderOptions?: object;
    /**
     * See "mp4-muxer" and "webm-muxer" for a list of options.
     */
    muxerOptions?: object;
    onStatusChange?: onStatusChangeCb;
};
/**
 * Options for recording initialisation. All optional.
 */
export type RecorderStartOptions = {
    /**
     * Overwrite the file name completely.
     */
    filename?: string;
    /**
     * Only initialised the recorder and don't call the first await recorder.step().
     */
    initOnly?: boolean;
};
/**
 * A callback to notify on the status change. To compare with RecorderStatus enum values.
 * @callback onStatusChangeCb
 * @param {number} RecorderStatus the status
 */
/**
 * @typedef {object} RecorderOptions Options for recording. All optional.
 * @property {string} [name=""] A name for the recorder, used as prefix for the default file name.
 * @property {number} [duration=10] The recording duration in seconds. If set to Infinity, `await canvasRecorder.stop()` needs to be called manually.
 * @property {number} [frameRate=30] The frame rate in frame per seconds. Use `await canvasRecorder.step();` to go to the next frame.
 * @property {boolean} [download=true] Automatically download the recording when duration is reached or when `await canvasRecorder.stop()` is manually called.
 * @property {string} [extension="mp4"] Default file extension: infers which Encoder is selected.
 * @property {string} [target="in-browser"] Default writing target: in-browser or file-system when available.
 * @property {object} [encoder] A specific encoder. Default encoder based on options.extension: GIF > WebCodecs > H264MP4.
 * @property {object} [encoderOptions] See `src/encoders` or individual packages for a list of options.
 * @property {object} [muxerOptions] See "mp4-muxer" and "webm-muxer" for a list of options.
 * @property {onStatusChangeCb} [onStatusChange]
 */
/**
 * @typedef {object} RecorderStartOptions Options for recording initialisation. All optional.
 * @property {string} [filename] Overwrite the file name completely.
 * @property {boolean} [initOnly] Only initialised the recorder and don't call the first await recorder.step().
 */
export class Recorder {
    /**
     * Sensible defaults for recording so that the recorder "just works".
     * @type {RecorderOptions}
     */
    static defaultOptions: RecorderOptions;
    /**
     * A mapping of extension to their mime types
     * @type {object}
     */
    static mimeTypes: object;
    /**
     * Create a Recorder instance
     * @class Recorder
     * @param {RenderingContext} context
     * @param {RecorderOptions} [options={}]
     */
    constructor(context: RenderingContext, options?: RecorderOptions);
    set width(value: any);
    get width(): any;
    set height(value: any);
    get height(): any;
    get stats(): {
        renderTime: number;
        secondsPerFrame: number;
        detail: string;
    };
    status: any;
    getParamString(): string;
    getDefaultFileName(extension: any): string;
    getSupportedExtension(): any;
    getSupportedTarget(): any;
    context: RenderingContext;
    encoder: WebCodecsEncoder | H264MP4Encoder | GIFEncoder | FrameEncoder;
    /**
     * Sets up the recorder internals and the encoder depending on supported features.
     * @private
     */
    private init;
    deltaTime: number;
    time: number;
    frame: number;
    frameTotal: number;
    startTime: Date;
    filename: any;
    /**
     * Start the recording by initializing and optionally calling the initial step.
     * @param {RecorderStartOptions} [startOptions={}]
     */
    start(startOptions?: RecorderStartOptions): Promise<void>;
    /**
     * Convert the context into something encodable (bitmap, blob, buffer...)
     * @private
     */
    private getFrame;
    /**
     * Encode a frame and increment the time and the playhead.
     * Calls `await canvasRecorder.stop()` when duration is reached.
     */
    step(): Promise<void>;
    /**
     * Stop the recording and return the recorded buffer.
     * If options.download is set, automatically start downloading the resulting file.
     * Is called when duration is reached or manually.
     * @returns {(ArrayBuffer|Uint8Array|Blob[]|undefined)}
     */
    stop(): (ArrayBuffer | Uint8Array | Blob[] | undefined);
    /**
     * Clean up the recorder and encoder
     */
    dispose(): Promise<void>;
    #private;
}
/**
 * *
 */
export type RecorderStatus = number;
/**
 * Enum for recorder status
 * @readonly
 * @enum {number}
 *
 * @example
 * ```js
 * // Check recorder status before continuing
 * if (canvasRecorder.status !== RecorderStatus.Stopped) {
 *   rAFId = requestAnimationFrame(() => tick());
 * }
 * ```
 */
export const RecorderStatus: Readonly<{
    Ready: 0;
    Initializing: 1;
    Recording: 2;
    Stopping: 3;
    Stopped: 4;
}>;
import WebCodecsEncoder from "./encoders/WebCodecsEncoder.js";
import H264MP4Encoder from "./encoders/H264MP4Encoder.js";
import GIFEncoder from "./encoders/GIFEncoder.js";
import FrameEncoder from "./encoders/FrameEncoder.js";
