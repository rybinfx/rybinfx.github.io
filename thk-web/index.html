<!DOCTYPE html>
<html lang="en">
<head>    
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>THK Sync</title>
  <style>
    html, body, div, canvas {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas {
      display: block;
    }
    .go {
      background-color: #ffffff19;
      border-radius: 64px;
      border: 1.0px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.747);
      
      position: absolute;
      bottom: 5%; left: 50%;
      transform: translateX(-50%);
      padding: 16px 26px;
      font-size: 20px;
      z-index: 10;
    }
    
    .go:active {
      background-color: white;
      color: black;
    }
    /* Centered div styling */
    #centeredText {
      color: rgba(255, 255, 255, 1.0);
      position: absolute;
      bottom: 55%; left: 50%;
      transform: translateX(-50%) translateY(50%);
      /* padding: 16px 26px; */
      line-height: 1.5;
      width: 90%;
      font-size: 1.0em;
      z-index: 10;
      text-align: center;
      transition: opacity 1s;
      opacity: 0.0;
      pointer-events: none;
    }






  .container {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    /* transform: translate(5%, 3%); */
    color: white;
    pointer-events: none;
    /* padding: 16px; */
  }

  .container-flex {
    /* width: 100%;
    height: 100%; */
    display: flex;
    flex-direction: column;
    /* pointer-events: none; */
  }
  
  .align-left {
    text-align: left;
    justify-content: left;
  }
  
  .align-right {
    text-align: right;
    justify-content: right;
  }

  .align-center {
    text-align: center;
    justify-content: center;
  }

  .header {
    display: flex;
    justify-content:space-between;
    align-items: center;
    /* padding: 10px; */
    /* background-color: #333; */
    height: 7vh;
    color: rgba(255, 255, 255, 0.8);
    /* margin: 32px; */
    /* width: 100%; */
  }

  .header-title {
    font-size: 1.0em;
    font-weight: 500;
    text-align: center;
    margin: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .header-sub {
    font-size: 0.6em;
    padding: 8px;
    margin: 8px;
    display: flex;
    align-items: center;
    width: 35%;
  }

  .content {
    /* flex: 1; */
    flex-grow: 1;
    /* pointer-events: none; */
    /* display: none; */
    /* background-color: #444;
    
    display: flex;
    justify-content: center;
    align-items: center; */
    position: relative;
  }

  .footer {
    display: flex;
    justify-content: space-between;
    flex-shrink: 1;
    /* padding: 10px; */
    /* background-color: #333; */
    /* height: 100px; */
    /* height: 10vw; */
    height: 96px;
  }

  .butt-div {
    /* display: flex; */
    /* height: 58px; */
    align-items: center;
    /* justify-content: center; */
    /* padding: 8px; */
    flex-shrink: 1;
    z-index: 100;
  }
  .go-butt-div {
    flex-grow: 1;
    flex-shrink: 0.6;
  }

  .butt {
    cursor: pointer;
    background-color: rgba(255, 255, 255, 0.0);
    border-radius: 60px;
    border: 2.0px solid rgba(255, 255, 255, 0.2);
    color: rgba(255, 255, 255, 0.5);
    font-size: 20px;
    z-index: 200;
    width: 60px;
    height: 60px;
    margin-left: 12px;
    margin-right: 12px;
    padding: 0;
    pointer-events: all;

  }

  .go-butt {
    width: 40vw;
    z-index: 120;
    /* border: 2.0px solid rgba(255, 255, 255, 0.5); */
  
  }

  .butt:active {
    background-color: rgba(255, 255, 255, 0.2);
    color: rgba(255, 255, 255, 0.8);
  }


  .circle {
    width: 60px;
    height: 60px;
    background-color: rgba(255, 255, 255, 0.0);
    border-radius: 50%; /* Makes it a circle */
    position: absolute;
    /* transform: translate(-50%, -50%); */
    cursor: pointer; /* Shows it's clickable */
    pointer-events: all;
    z-index: 200;
    font-size: 0.7em;
    text-align: center;
    /* Align text vertically */
    display: flex;
    align-items: center;
    justify-content: center;
    color: rgba(255, 255, 255, 0.5);

  }

  .circle_tl {
    left: 10%;
    top: 10%;
  }
  .circle_tr {
    right: 10%;
    top: 10%;
  }
  .circle_bl {
    left: 10%;
    bottom: 10%;
  }
  .circle_br {
    right: 10%;
    bottom: 10%;
  }


  .ui-canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }



  </style>
</head>
<body>
  <div>


    <div class="container">
      <div class="container-flex">
        <div class="header">
          <div class="header-sub align-left" id="i_topleft">8°37'58.5"S</div>
          <div class="header-title"><div class="header-title">THK CREATOR</div></div>
          <div class="header-sub align-right" id="i_topright">115°05'50.5"E</div>
        </div>
        <div class="content">
          <!-- <div class="circle circle_tl" id="c1">N/A</div>
          <div class="circle circle_tr" id="c2">MOTION</div> -->
          <div class="circle circle_bl" id="c3">COLOR</div>
          <div class="circle circle_br" id="c4">SHAPE</div>
        </div>
        <div class="footer">
          <div class="butt-div align-left"><button class="butt" id="info">
            <svg style="transform: translateY(2px) scale(1.1);" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff80"><path d="M424-320q0-81 14.5-116.5T500-514q41-36 62.5-62.5T584-637q0-41-27.5-68T480-732q-51 0-77.5 31T365-638l-103-44q21-64 77-111t141-47q105 0 161.5 58.5T698-641q0 50-21.5 85.5T609-475q-49 47-59.5 71.5T539-320H424Zm56 240q-33 0-56.5-23.5T400-160q0-33 23.5-56.5T480-240q33 0 56.5 23.5T560-160q0 33-23.5 56.5T480-80Z"/></svg>
            <!-- <svg style="transform: translateY(2.5px) scale(1.3);" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff80"><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg> -->
            
          </div>
          <div class="butt-div align-center go-butt-div"><button class="butt go-butt" id="go">GO</button></div>
          <div class="butt-div align-right"><button class="butt" id="save">
            
            <svg style="transform: translateY(2px) scale(1.3);" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff80"><path d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"/></svg>

          </button></div>
        </div>
      </div>
    </div>

    <span id="centeredText">Entity sent to THK tower</span>
    <canvas id="ui_canvas" class="ui-canvas"></canvas>
    <canvas id="lighthouse_canvas"></canvas>

    
  </div>

  <script src="twgl.min.js"></script>
  <script src="thk.js"></script>


  <script type="module">
    import { initRecorder } from './recorder.js';




    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const latitude = position.coords.latitude;
          const longitude = position.coords.longitude;
          const altitude = position.coords.altitude || 0; // Use 0 if altitude isn't available
          console.log(`Latitude: ${latitude}, Longitude: ${longitude}, Altitude: ${altitude}`);
          
          document.getElementById("i_topleft").innerHTML = latitude.toFixed(4);
          document.getElementById("i_topright").innerHTML = longitude.toFixed(4);
        },
        (error) => {
          console.error("Error retrieving location:", error);
        }
      );
    } else {
      console.error("Geolocation is not supported by this browser.");
}


    const params = {
      seed: 0,
      speed: 0.1,
      val1: Math.random()*100.0,
      val2: Math.random()*100.0,
      tx: Math.random()*100.0,
      ty: Math.random()*100.0,
      val1a: 0.0,
      val1b: 0.0,
      val2a: 0.0,
      val2b: 0.0,
      val3a: 0.0,
      val3b: 0.0,
      val4a: 0.0,
      val4b: 0.0
    }


    
    function initUI() {
      const ui_canvas = document.getElementById("ui_canvas");
      const ui = ui_canvas.getContext("2d");
      const canvas = document.getElementById("lighthouse_canvas");
      const sl1 = document.getElementById("c1");
      const sl2 = document.getElementById("c2");
      const sl3 = document.getElementById("c3");
      const sl4 = document.getElementById("c4");

      function get_pos(e) {
        let x = e.clientX;
        let y = e.clientY;
        if (e.touches) {
          x = e.touches[0].clientX;
          y = e.touches[0].clientY;
        }
        const rect = ui_canvas.getBoundingClientRect();
        x -= rect.left;
        y -= rect.top;
        return { x, y };
      }
      

      function initSlider(sl) {

        const idx = parseInt(sl.id[1]) - 1;
        let right = idx % 2 === 1;
        let bottom = idx > 1;

        
        let isDragging = false;
        let pX = 0;
        let pY = 0;
        let pA = 0;
        let value = Math.random()*100.0;
        let value_target = value;
        let value_b = Math.random();
        let value_b_target = value_b;
        
        if (idx == 1) {
          value = 0.5;
          value_target = 0.5;
        } else {
          value = Math.random()*100.0;
          value_target = value;
        }
        const param_name_a = "val" + (idx+1) + "a";
        params[param_name_a] = value_target;
        const param_name_b = "val" + (idx+1) + "b";
        params[param_name_b] = value_b;

        
        const rect = ui_canvas.getBoundingClientRect();
        let slX = sl.getBoundingClientRect().left;
        let slY = sl.getBoundingClientRect().top;


        function handleStart(event) {
          event.preventDefault();
          isDragging = true;
          handleMove(event);
        }

        function handleEnd(event) {
          if (!isDragging) return;
          event.preventDefault();
          isDragging = false;
        }

        function handleMove(event) {
          if (!isDragging) return;
          // event.preventDefault();

          const pos = get_pos(event);
          pX = pos.x;
          pY = pos.y;
        }

        function update() {

          slX = sl.getBoundingClientRect().left + sl.clientWidth / 2;
          slY = sl.getBoundingClientRect().top + sl.clientHeight / 2;

          
          let dist_scale = canvas.width;
          let dist = Math.sqrt((pX - slX) * (pX - slX) + (pY - slY) * (pY - slY));
          let dists = dist / dist_scale;
          
          let ax = (pX - slX) / dist;
          let ay = (pY - slY) / dist;

          let angle = Math.atan2(ay, ax);
          let dA = angle - pA;
          if (dA > Math.PI) dA -= Math.PI * 2;
          if (dA < -Math.PI) dA += Math.PI * 2;


          dA *= Math.pow(dists, 1.3)*3.0;
          if (isDragging) {
            value_target += dA;
            value_b_target = Math.min(Math.max(0.0, dists), 1.0);
          }
          pA = angle;

          let mp = Math.PI/2;

          let amin = 0.125;
          if (idx == 1) {
            amin += 0.25;
          }
          if (idx == 2) {
            amin += 0.75;
          }
          if (idx == 3) {
            amin += 0.5;
          }


          let asize = 0.5;

          // let amax = Math.PI/2 + Math.PI/4;

          // if (idx == 1) {
          //   amin += Math.PI/2;
          //   amax += Math.PI/2;
          // }
          // if (idx == 2) {
          //   amin += Math.PI;
          //   amax += Math.PI;
          // }
  

          function aval(a) {
            let av = a / Math.PI / 2 + 0.5;
            av = av - amin;
            while (av < 0) av += 1.0;
            av = Math.min(1.0, Math.max(0.0, av));
            av = ((av-0.5)*2.0)+0.5;
            av = Math.min(1.0, Math.max(0.0, av));

            // av = (a - amin) / (amax - amin);
            // a = a / (amax - amin);
            // return Math.min(1.0, Math.max(0.0, a));
            return av;
          }

          // let av = aval(angle);
          // let av1 = av - dists*0.5;
          // let av2 = av + dists*0.5;
          // av1 = Math.min(1.0, Math.max(0.0, av1));
          // av2 = Math.min(1.0, Math.max(0.0, av2));

          // if (isDragging) {
          //   console.log(av);
          // }

          // angle = aclamp(angle);

          // let av = aval(angle);


          // angle = amin + av*(amax-amin);

          let a0 = value_target*2.0;
          let a1 = a0 - Math.min(1.0, value_b_target)*Math.PI*0.9;
          let a2 = a0 + Math.min(1.0, value_b_target)*Math.PI*0.9;
          // let a0 = (amin*Math.PI*2.0) + (av-0.5)*Math.PI;
          // let a1 = (amin*Math.PI*2.0) + (av1-0.5)*Math.PI;
          // let a2 = (amin*Math.PI*2.0) + (av2-0.5)*Math.PI;
          // let a1_ = (amin*Math.PI*2.0) + (0.0-0.5)*Math.PI;
          // let a2_ = (amin*Math.PI*2.0) + (1.0-0.5)*Math.PI;
          let a1_ = a1;
          let a2_ = a2;
          

          // a1 = aclamp(a1);
          // a2 = aclamp(a2);

          let sllw = 5;
          let slw = sl.clientWidth / 2 - sllw/2+12;

          ui.lineWidth = sllw;
          ui.lineCap = "round";
          ui.strokeStyle = "rgba(255, 255, 255, 0.2)";
          // ui.beginPath();
          // ui.arc(slX, slY, slw, a1_, a2_);
          // ui.stroke();
          
          ui.strokeStyle = "rgba(255, 255, 255, 0.33)";
          ui.beginPath();
          ui.arc(slX, slY, slw, a1, a2);
          ui.stroke();


          ui.lineWidth = 1.0;
          ui.strokeStyle = "rgba(255, 255, 255, 0.2)";
          ui.beginPath();
          ui.arc(slX, slY, slw+sllw/2.0, 0.0, Math.PI*2.0);
          ui.stroke();

          let param_a_damp = 0.5;
          let param_b_damp = 0.1;
          function lerp(a, b, t) {
            return a + (b - a) * t;
          }
          const param_name_a = "val" + (idx+1) + "a";
          const param_name_b = "val" + (idx+1) + "b";
          params[param_name_a] = lerp(params[param_name_a], value_target, param_a_damp);
          params[param_name_b] = lerp(params[param_name_b], value_b_target, param_b_damp);
          if (idx == 1) {
            params.speed = params[param_name_a];
          }
          
          // params[param_name_b] = lerp(params[param_name_b], av, param_damp);

          if (isDragging) {


            


            ui.fillStyle = "rgba(255, 255, 255, "+(1.0-dists)*(1.0-dists)*0.6+")";
            // ui.beginPath();
            // ui.arc(slX, slY, sl.clientWidth/2*Math.pow(Math.max(0.001, dists), 0.25), 0, Math.PI*2.0);
            // ui.fill();



            // Stroke a circle on pointer position

            let cs = 64;
            ui.strokeStyle = "rgba(255, 255, 255, "+(1.0-dists)*0.25+")";
            ui.lineWidth = 2;

            // ui.beginPath();
            // ui.arc(pX, pY, cs, 0, 2 * Math.PI);
            // ui.stroke();

            ui.beginPath();
            ui.arc(slX, slY, dist, 0, 2 * Math.PI);
            ui.stroke();

            // ui.beginPath();
            // ui.arc(slX, slY, maxDist, 0, 2 * Math.PI);
            // ui.stroke();

            // ui.beginPath();
            // ui.moveTo(slX+ax*sl.clientWidth/2, slY+ay*sl.clientHeight/2);
            // ui.lineTo(pX, pY);
            // ui.stroke();

            let a1x = Math.cos(a1);
            let a1y = Math.sin(a1);
            let a2x = Math.cos(a2);
            let a2y = Math.sin(a2);
            // ui.beginPath();
            // ui.moveTo(slX+a1x*(slw+sllw/2), slY+a1y*(slw+sllw/2));
            // ui.lineTo(slX+a1x*dist, slY+a1y*dist);
            // ui.stroke();
            // ui.beginPath();
            // ui.moveTo(slX+a2x*(slw+sllw/2), slY+a2y*(slw+sllw/2));
            // ui.lineTo(slX+a2x*dist, slY+a2y*dist);
            // ui.stroke();
            



          }
        }

        sl.addEventListener('mousedown', handleStart, false);
        sl.addEventListener('mousemove', handleMove, false);
        sl.addEventListener('mouseup', handleEnd, false);
        ui_canvas.addEventListener('mousemove', handleMove, false);
        ui_canvas.addEventListener('mouseup', handleEnd, false);

        sl.addEventListener('touchstart', handleStart, false);
        sl.addEventListener('touchmove', handleMove, false);
        sl.addEventListener('touchend', handleEnd, false);
        sl.addEventListener('touchcancel', handleEnd, false);
        ui_canvas.addEventListener('touchmove', handleMove, false);
        ui_canvas.addEventListener('touchend', handleEnd, false);
        ui_canvas.addEventListener('touchcancel', handleEnd, false);

        return update;

      }

      // const update1 = initSlider(sl1);
      // const update2 = initSlider(sl2);
      const update3 = initSlider(sl3);
      const update4 = initSlider(sl4);


      let isDragging = false;
      let prevX = 0;
      let prevY = 0;
      let pX = 0;
      let pY = 0;
      let velX = 0;
      let velY = 0;
      let damp = 0.1;
      
      function lerpf(a, b, t) {
        return a + (b - a) * t;
      }

      function handleStart(event) {
        event.preventDefault();
        isDragging = true;
        let pos = get_pos(event);
        pX = pos.x;
        pY = pos.y;
        prevX = pX;
        prevY = pY;
        handleMove(event);
      }

      function handleEnd(event) {
        if (!isDragging) return;
        event.preventDefault();
        isDragging = false;
      }

      function handleMove(event) {
        if (!isDragging) return;
        event.preventDefault();
        const pos = get_pos(event);
        pX = pos.x;
        pY = pos.y;
      }

      ui_canvas.addEventListener('mousedown', handleStart, false);
      ui_canvas.addEventListener('mousemove', handleMove, false);
      ui_canvas.addEventListener('mouseup', handleEnd, false);

      ui_canvas.addEventListener('touchstart', handleStart, false);
      ui_canvas.addEventListener('touchmove', handleMove, false);
      ui_canvas.addEventListener('touchend', handleEnd, false);
      ui_canvas.addEventListener('touchcancel', handleEnd, false);


      function updateUI() {
        const client_width = canvas.clientWidth;
        const client_height = canvas.clientHeight;
        if (client_width !== ui_canvas.width || client_height !== ui_canvas.height) {
          ui_canvas.width = client_width;
          ui_canvas.height = client_height;
        }
        if (client_width !== canvas.width || client_height !== canvas.height) {
          canvas.width = client_width;
          canvas.height = client_height;
        }



        ui.clearRect(0, 0, ui_canvas.width, ui_canvas.height);
        let info_op = window.getComputedStyle(document.getElementById("centeredText")).opacity;
        
        ui.fillStyle = ui.fillStyle = "rgba(0, 0, 0, "+(info_op*0.5)+")";
        ui.fillRect(0, 0, ui_canvas.width, ui_canvas.height);  

        // update1();
        // update2();
        update3();
        update4();


        let offX = 0.0;
        let offY = 0.0;
        if (isDragging) {
          offX = pX - prevX;
          offY = pY - prevY;
          let nomrf = ui_canvas.width*4;
          offX = offX / nomrf;
          offY = offY / nomrf;
          velX = lerpf(velX, offX, damp);
          velY = lerpf(velY, offY, damp);
        } else {
          velX = lerpf(velX, 0, damp);
          velY = lerpf(velY, 0, damp);
        }
        params.tx += velX;
        params.ty += velY;
        prevX = pX;
        prevY = pY;



        // Render progress bar
        let progress = rec_param.progress;
        // ui.fillStyle = "rgba(255, 255, 255, 0.05)";
        // ui.fillRect(0, ui_canvas.height-8, ui_canvas.width, 8);
        ui.fillStyle = "rgba(255, 255, 255, 0.5)";
        ui.fillRect(0, ui_canvas.height-8, ui_canvas.width*progress, 8);
        



      }

      return updateUI;

    }

    function showText() {
        const centeredText = document.getElementById("centeredText");
        centeredText.style.opacity = 1.0; // Show the text

        setTimeout(() => {
          centeredText.style.opacity = 0.0; // Hide the text after 3 seconds
        }, 3000); // 3000ms = 3 seconds
    }

    const lighthouse_canvas = document.getElementById("lighthouse_canvas");

    const rec_param = { recording: false, progress: 0.0 };
    function resizeCanvas() {
      if (rec_param.recording) {
        return;
      }
      lighthouse_canvas.width = window.innerWidth;
      lighthouse_canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();


    
    const goButton = document.getElementById("go");
    goButton.addEventListener("click", function () {
      const jsonData = params;
      fetch('https://thk-tower.glitch.me/send-json', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
          },
          body: JSON.stringify(jsonData),
      })
      .then(response => response.json())
      .then(data => {
        console.log('Success:', data);
        let time = Math.floor(Date.now() / 1000);
        let time2 = data.message;
        time = time2 - time;
        time = Math.round(time);
        if (time < 1) {
          time = 0;
          document.getElementById("centeredText").innerHTML = "Entity will be displayed now";
        } else {
          document.getElementById("centeredText").innerHTML = "Entity will be displayed in " + time+'s';
        }
        showText();
      })
      .catch((error) => {
          console.error('Error:', error);
      });
    });

    const updateUI = initUI();

    const thk_render = lighthouse_generate(lighthouse_canvas, params, updateUI);
    console.log('fn', thk_render);
    initRecorder(lighthouse_canvas, thk_render, rec_param);


    const saveButton = document.getElementById("save");
    saveButton.addEventListener("click", function () {
      rec_param.recording = true;
      console.log('recording', rec_param.recording);
    });

    const infoButton = document.getElementById("info");
    infoButton.addEventListener("click", function () {
      document.getElementById("centeredText").innerHTML = "Welcome to THK Creator<br>Drag the circles to adjust the parameters<br>Click GO to send the entity to the THK tower";
      showText();
    });
    infoButton.click();


</script>



</body>
</html>