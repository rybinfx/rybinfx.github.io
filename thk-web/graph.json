{"glsl": "#version 300 es\nprecision highp float;\nprecision highp int;\n\nlayout(location = 0) out vec4 fragPos;\nlayout(location = 1) out vec4 fragColor;\nin vec4 vUV;\n// varying vec4 vUV;\nuniform vec2 res;\nuniform float time;\nuniform int numPoints;\nuniform sampler2D u_tex0;\nuniform sampler2D u_tex1;\n// uniform int MODE;\n\nuniform vec2 tex0_res;\nuniform vec2 tex1_res;\nuniform vec2 tex2_res;\n\n\nuniform float u_off;\nuniform float u_resx;\nuniform float u_resy;\nuniform float u_val1;\nuniform float u_val2;\nuniform float u_mix1;\nuniform float u_mix2;\nuniform float u_move;\nuniform float u_tx;\nuniform float u_ty;\nuniform float u_val1a;\nuniform float u_val1b;\nuniform float u_val2a;\nuniform float u_val2b;\nuniform float u_val3a;\nuniform float u_val3b;\nuniform float u_val4a;\nuniform float u_val4b;\nuniform float u_chan18;\nuniform float u_chan19;\nuniform float u_chan20;\nuniform float u_chan21;\nuniform float u_reflect;\nuniform float u_weight_low;\nuniform float u_weight_high;\nuniform float u_diff_u;\nuniform float u_diff_v;\nuniform float u_seed;\nuniform float u_tex1w;\nuniform float u_tex1h;\nuniform float u_tex2w;\nuniform float u_tex2h;\nuniform float u_tex3w;\nuniform float u_tex3h;\nuniform float u_outw;\nuniform float u_outh;\n\n\n#define PI 3.1415926538\n\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\n\n\n\n\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand2(float x, float y){return fract(sin(dot(vec2(x,y), vec2(12.9898,78.233))) * 43758.5453123);}\n\n\n////////////////////////////////////////////////////////////////////////////////////\n// Random\n////////////////////////////////////////////////////////////////////////////////////\nfloat ns_rand1(float n){return fract(sin(n) * 43758.5453123);}\nfloat ns_rand2(float x, float y){return fract(sin(dot(vec2(x,y), vec2(12.9898,78.233))) * 43758.5453123);}\n////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////\n// Value Noise\n////////////////////////////////////////////////////////////////////////////////////\nfloat ns_value1_rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat ns_value1(float x) {\n  float fx = floor(x);\n  float u = fract(x);\n\treturn mix(ns_value1_rand(fx), ns_value1_rand(fx+1.0), u) * 2.0 - 1.0;\n}\n////////////////////////////////////////////////////////////////////////////////////\nfloat ns_value2_rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898,78.233))) * 43758.5453123);\n}\nfloat ns_value2(vec2 p){\n  float ipx = floor(p.x);\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\n  // u = smoothstep(0.0, 1.0, u);\n\n  float n00 = ns_value2_rand(floor(ip+vec2(0.0,0.0)));\n  float n01 = ns_value2_rand(floor(ip+vec2(0.0,1.0)));\n  float n10 = ns_value2_rand(floor(ip+vec2(1.0,0.0)));\n  float n11 = ns_value2_rand(floor(ip+vec2(1.0,1.0)));\n\n\tfloat res = mix(\n    mix(n00, n01, u.y),\n    mix(n10, n11, u.y),\n    u.x\n  );\n\n  // res = mix(ns_value2_rand(vec2(ipx, 0.0)), ns_value2_rand(vec2(floor(ipx+1.0), 0.0)), u.x);\n\n\treturn res * 2.0 - 1.0;\n}\n////////////////////////////////////////////////////////////////////////////////////\nfloat ns_value3_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 ns_value3_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 ns_value3_perm(vec4 x){return ns_value3_mod289(((x * 34.0) + 1.0) * x);}\nfloat ns_value3(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = ns_value3_perm(b.xyxy);\n    vec4 k2 = ns_value3_perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = ns_value3_perm(c);\n    vec4 k4 = ns_value3_perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return (o4.y * d.y + o4.x * (1.0 - d.y)) * 2.0 - 1.0;\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n////////////////////////////////////////////////////////////////////////////////////\nvec4 ns_perlin2_permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec2 ns_perlin2_fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat ns_perlin2(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = ns_perlin2_permute(ns_perlin2_permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = ns_perlin2_fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n////////////////////////////////////////////////////////////////////////////////////\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n////////////////////////////////////////////////////////////////////////////////////\nvec4 ns_perlin3_permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 ns_perlin3_taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 ns_perlin3_fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat ns_perlin3(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = ns_perlin3_permute(ns_perlin3_permute(ix) + iy);\n  vec4 ixy0 = ns_perlin3_permute(ixy + iz0);\n  vec4 ixy1 = ns_perlin3_permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = ns_perlin3_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = ns_perlin3_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = ns_perlin3_fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////////////////////////\n// Simplex 2D noise\n////////////////////////////////////////////////////////////////////////////////////\nvec3 ns_simplex2_permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat ns_simplex2(vec2 v){\n  vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = ns_simplex2_permute( ns_simplex2_permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n////////////////////////////////////////////////////////////////////////////////////\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n////////////////////////////////////////////////////////////////////////////////////\nvec4 ns_simplex3_permute(vec4 x){\n    vec4 y = ((x*34.0)+1.0)*x;\n    return y - (floor(y/289.0) * 289.0);\n  }\nvec4 ns_simplex3_taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat ns_simplex3(vec3 v){\n  if (v.x == v.y) v.y += 0.00001;\n  if (v.y == v.z) v.z += 0.00001;\n  if (v.z == v.x) v.z += 0.00001;\n  vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz); // HERE SOMETHING HAPPENING g.x, g.z, i2.xz, i1.xy\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = ns_simplex3_permute( ns_simplex3_permute( ns_simplex3_permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = ns_simplex3_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n////////////////////////////////////////////////////////////////////////////////////\n\n\n\n// ////////////////////////////////////////////////////////////////////////////////////\n// // Rdapp Distorion\n// ////////////////////////////////////////////////////////////////////////////////////\n// #define ns_rdapp_PI 3.1415926538\n// float ns_rdapp_rand(float n){return fract(sin(n) * 43758.5453123);}\n// vec3 ns_rdapp_rand_ch3(float n){return vec3(ns_rdapp_rand(n), ns_rdapp_rand(n+1.0/3.0), ns_rdapp_rand(n+2.0/3.0));}\n// vec3 ns_rdapp(vec3 p, float time, float amp, float freq, float astep, float fstep, int seed) {\n//   vec3 p0 = p;\n// \tp += amp*pow(astep, 0.0)*sin((pow(fstep, 0.0)*freq*p.yzx+normalize(ns_rdapp_rand_ch3(float(seed+0))-0.5)*ns_rdapp_PI*2.0*time+ns_rdapp_rand_ch3(seed+1))*ns_rdapp_PI*2.0);\n// \tp += amp*pow(astep, 1.0)*sin((pow(fstep, 1.0)*freq*p.yzx+normalize(ns_rdapp_rand_ch3(float(seed+2))-0.5)*ns_rdapp_PI*2.0*time+ns_rdapp_rand_ch3(seed+3))*ns_rdapp_PI*2.0);\n// \tp += amp*pow(astep, 2.0)*sin((pow(fstep, 2.0)*freq*p.yzx+normalize(ns_rdapp_rand_ch3(float(seed+4))-0.5)*ns_rdapp_PI*2.0*time+ns_rdapp_rand_ch3(seed+5))*ns_rdapp_PI*2.0);\n// \tp += amp*pow(astep, 4.0)*sin((pow(fstep, 3.0)*freq*p.yzx+normalize(ns_rdapp_rand_ch3(float(seed+6))-0.5)*ns_rdapp_PI*2.0*time+ns_rdapp_rand_ch3(seed+7))*ns_rdapp_PI*2.0);\n// \treturn p-p0;\n// }\n// ////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\nfloat parabola( float x, float k )\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b)/(pow(a,a)*pow(b,b));\n    return k*pow(x,a)*pow(1.0-x,b);\n}\n\n\n\nvec2 rot2(vec2 v, float a) {\n\ta = a*PI*2.0;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\nvec2 rot2(float a) {\n\treturn rot2(vec2(0.0, 1.0), a);\n}\nfloat n11(float x) { return x*2.0-1.0; }\nfloat n01(float x) { return x*0.5+0.5; }\n\nvec3 bezier(vec3 A, vec3 B, vec3 C, vec3 D, float t) {\n  vec3 E = mix(A, B, t);\n  vec3 F = mix(B, C, t);\n  vec3 G = mix(C, D, t);\n\n  vec3 H = mix(E, F, t);\n  vec3 I = mix(F, G, t);\n\n  vec3 P = mix(H, I, t);\n\n  return P;\n}\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat integralSmoothstep( float x, float T )\n{\n    if( x>T ) return x - T/2.0;\n    return x*x*x*(1.0-x*0.5/T)/T/T;\n}\n\n// float rsplit(float x, int n) {\n// \tfloat sum = 0;\n// \tfloat rx = 0;\n// \tfor (int i = 0; i < n; i++) {\n// \t\tfloat t = time*0.5+i*0.2;\n// \t\tfloat npos = floor(t+i*10) + gain(fract(t), 4);\n// \t\tfloat r = pow(rnoise(npos), 1);\n// \t\trx += mix(0, r, clamp(x*n-float(i), 0.0, 1.0));\n// \t\tsum += r;\n// \t}\n// \trx /= sum;\n//   return rx;\n// }\n\n\n\n\n// float sinnoise(float x, int n, float seed) {\n//   float val = 0;\n//   float ampaccum = 0;\n//   for (int i = 0; i < n; i++) {\n//     float amp = rand(seed+i);\n//     float freq = rand(seed+i+100);\n//     // amp = 1;\n//     amp = gain(amp,4);\n//     freq += 0.1;\n//     ampaccum += amp;\n//     val += sin(x*freq*PI*2) * amp;\n//   }\n//   val /= ampaccum;\n//   return val;\n// }\n\n\n// float sinnoise(float x, float y, int n, float seed) {\n//   float val = 0;\n//   float ampaccum = 0;\n//   for (int i = 0; i < n; i++) {\n//     float amp = sinnoise(y, n, rand(seed+i+200))*0.5+0.5;\n//     // float amp = rand(time);\n//     float freq = rand(seed+i+300);\n//     // amp = 1/freq;\n//     amp = gain(amp,4);\n//     freq += 0.1;\n//     ampaccum += amp;\n//     val += sin(x*freq*PI*2) * amp;\n//   }\n//   val /= ampaccum;\n//   return val;\n// }\n\n\n// float sinnoise(float x, float y, float z, int n, float seed) {\n//   float val = 0;\n//   float ampaccum = 0;\n//   for (int i = 0; i < n; i++) {\n//     float amp = rand(seed+i);\n//     float freqX = (rand(seed+i+100)*2-1);\n//     float freqY = (rand(seed+i+200)*2-1);\n//     float freqZ = (rand(seed+i+300)*2-1);\n//     // amp = (freqX+freqY+freqZ);\n//     // amp = gain(amp,4);\n//     ampaccum += amp;\n//     // ampaccum += 0.3;\n//     float offset = rand(seed+i+400);\n//     val += sin(x*freqX*PI*2+y*freqY*PI*2+z*freqZ*PI*2+offset*2*PI) * amp;\n//   }\n//   val /= ampaccum;\n//   return val;\n// }\n\n// float sinnoise2(float x, float y, float z, int n, float seed) {\n//   float val = 0;\n//   float ampaccum = 0;\n//   for (int i = 0; i < n; i++) {\n//     float freq = 1.0;\n//     float amp = sinnoise(x*freq, y*freq, z*freq, 1, seed+50);\n//     float freqX = rand(seed+i+100)*2-1;\n//     float freqY = rand(seed+i+200)*2-1;\n//     float freqZ = rand(seed+i+300)*2-1;\n//     // amp = (freqX+freqY+freqZ);\n//     // amp = gain(amp,4);\n//     // ampaccum += amp;\n//     ampaccum += 1.0/3;\n//     float offset = rand(seed+i+400);\n//     val += sin(x*freqX*PI*2+y*freqY*PI*2+z*freqZ*PI*2+offset*2*PI) * amp;\n//   }\n//   val /= ampaccum;\n//   return val;\n// }\n\n\n\n\n\n\n\nstruct PData {\n\tvec3 p;\n\tfloat w;\n\tvec3 hsv;\n\tfloat a;\n\tvec4 extra_0;\n};\n\nstruct Seg {\n\tfloat idx;\n\tfloat size;\n\tfloat point;\n\tfloat npoints;\n};\n\nSeg seg_even(float point, float npoints, float size) {\n\tSeg new;\n\tnew.size = size;\n\tnew.npoints = float(int(npoints / size));\n\tnew.idx = float(int(point / new.npoints));\n\tnew.point = float(int(point-new.idx*new.npoints));\n\treturn new;\n}\n\n\nPData draw() {\n\tfloat point = float(int(vUV.t*res.y)*int(res.x)+int(vUV.s*res.x));\n\tfloat npoints = float(numPoints);\n\n\tvec3 pos;\n\tfloat alpha;\n\tfloat weight;\n\tfloat hue;\n\tfloat sat;\n\tfloat val;\n\tvec4 extra_0;\n\tvec4 extra_1;\n\tvec4 extra_2;\n\tvec4 extra_3;\n\n\n\t// Mesh Code\n\tSeg Clone_0 = seg_even(float(int(point)), float(int(npoints)), float(int(1)));\n\tSeg Clone_1 = seg_even(float(int(Clone_0.point)), float(int(Clone_0.npoints)), float(int(9)));\n\tSeg Clone_2 = seg_even(float(int(Clone_1.point)), float(int(Clone_1.npoints)), float(int(21)));\n\tSeg Clone_3 = seg_even(float(int(Clone_2.point)), float(int(Clone_2.npoints)), float(int(354)));\n\t\n\n\t// Main Code Defs\n\tvec3 node10 = vec3(0.0, 0.0, 0.0);\n\tfloat node29 = float(Clone_0.idx);\n\tfloat node33 = float(Clone_1.idx);\n\tfloat node24 = float(((((node29 * 9.0) - node29) - 4.0) + node33));\n\tfloat node21 = float((float(node24) / 9.0));\n\tfloat node60 = (u_off * 0.1);\n\tfloat node57 = (float((node60 * 0.1)) * Clone_3.size);\n\tfloat node53 = float((Clone_3.idx + fract(node57)));\n\tbool node48 = (Clone_3.size > 1.0);\n\tbool node51 = (!node48);\n\tfloat node47_out0;\n\tif (node48) {\n\t\tnode47_out0 = (node53 / Clone_3.size);\n\t} else {\n\t\tnode47_out0 = fract((node53 + 0.5));\n\t}\n\tfloat node45 = floor(node47_out0);\n\tfloat node69 = fract(node47_out0);\n\tfloat node79 = (u_val4a * 0.2);\n\tfloat node78 = (node69 - node79);\n\tbool node83 = (u_reflect > 0.5);\n\tfloat node82_out0;\n\tif (node83) {\n\t\tnode82_out0 = (parabola((node24 / 32.0), 1.0) * 6.0);\n\t} else {\n\t\tbool node95 = (Clone_1.size > 1.0);\n\t\tfloat node94_out0;\n\t\tif (node95) {\n\t\t\tnode94_out0 = (node33 / (Clone_1.size - 1.0));\n\t\t} else {\n\t\t\tnode94_out0 = 0.5;\n\t\t}\n\t\tnode82_out0 = parabola(node94_out0, 1.0);\n\t}\n\tvec2 node77 = vec2(node78, node82_out0);\n\tvec2 node109 = vec2(node78, (node82_out0 + 0.12121));\n\tfloat node67 = gain(pow(node69, pow(2.0, (ns_simplex2((vec2(node77.x, node77.y) / 1.5)) * 3.0))), pow(2.0, (ns_simplex2((vec2(node109.x, node109.y) / 1.5)) * 3.0)));\n\tfloat node127 = (node69 * 8.0);\n\tfloat node126 = (node127 - node79);\n\tbool node138 = (Clone_2.size > 1.0);\n\tfloat node137_out0;\n\tif (node138) {\n\t\tnode137_out0 = (float(Clone_2.idx) / (Clone_2.size - 1.0));\n\t} else {\n\t\tnode137_out0 = 0.5;\n\t}\n\tbool node133 = (Clone_1.idx < 4.0);\n\tfloat node132_out0;\n\tif (node133) {\n\t\tnode132_out0 = (1.0 - node137_out0);\n\t} else {\n\t\tbool node147 = (Clone_1.idx != 4.0);\n\t\tfloat node146_out0;\n\t\tif (node147) {\n\t\t\tnode146_out0 = node137_out0;\n\t\t} else {\n\t\t\tnode146_out0 = (abs((node137_out0 - 0.5)) + 0.5);\n\t\t}\n\t\tnode132_out0 = node146_out0;\n\t}\n\tvec3 node124 = vec3((node126 + 10.0), node82_out0, (node132_out0 * 0.33));\n\tfloat node163 = node124.x;\n\tfloat node164 = node124.y;\n\tfloat node165 = node124.z;\n\tvec3 node123 = (node124 + (vec3(((gain(((ns_simplex3((vec3(node163, node164, node165) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node163, node164, (node165 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node163, node164, (node165 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0)) * 0.1));\n\tvec3 node200 = vec3((node126 + 20.0), node82_out0, ((node132_out0 * 2.0) + 10.0));\n\tfloat node215 = node200.x;\n\tfloat node216 = node200.y;\n\tfloat node217 = node200.z;\n\tvec3 node199 = (node200 + (vec3(((gain(((ns_simplex3((vec3(node215, node216, node217) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node215, node216, (node217 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node215, node216, (node217 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0)) * 0.1));\n\tfloat node65 = ((node67 + (((gain(((ns_simplex3((vec3(node123.x, node123.y, node123.z) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0) * 0.15)) + (((gain(((ns_simplex3((vec3(node199.x, node199.y, node199.z) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0) * 0.0125));\n\tfloat node44 = (node45 + node65);\n\tvec4 node17 = vec4((0.5 + (node21 * mix(0.2, 0.8, n01(cos((((node44 + 0.5) * 3.141592653589793) * 2.0)))))), node44, 0.0, 0.0);\n\tvec2 node15 = vec2(node17.x, node17.y);\n\tfloat node275 = (cos((u_off * 0.25)) * 4.0);\n\tfloat node290 = float((Clone_3.idx - floor(node57)));\n\tfloat node288_out0;\n\tif (node48) {\n\t\tnode288_out0 = (node290 / Clone_3.size);\n\t} else {\n\t\tnode288_out0 = fract((node290 + 0.5));\n\t}\n\tfloat node283 = pcurve(fract(((node288_out0 * 8.0) + (node60 * 3.0))), 1.0, 2.0);\n\tfloat node279 = (node82_out0 + ((n11(node283) / 8.0) * 4.0));\n\tfloat node297 = (node132_out0 * 0.5);\n\tvec3 node272 = vec3((node69 - (node275 * 8.0)), node279, node297);\n\tfloat node310 = node272.x;\n\tfloat node311 = node272.y;\n\tfloat node312 = node272.z;\n\tfloat node322 = (node310 * 2.0);\n\tfloat node323 = (node311 * 2.0);\n\tfloat node324 = (node312 * 2.0);\n\tvec3 node271 = (node272 + (vec3(((((gain(((ns_simplex3((vec3(node310, node311, node312) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node322, node323, node324) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5), ((((gain(((ns_simplex3((vec3(node310, node311, (node312 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node322, node323, (node324 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5), ((((gain(((ns_simplex3((vec3(node310, node311, (node312 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node322, node323, (node324 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5)) * 0.1));\n\tfloat node270 = node271.x;\n\tfloat node367 = node271.y;\n\tfloat node368 = node271.z;\n\tfloat node378 = (node270 * 2.0);\n\tfloat node379 = (node367 * 2.0);\n\tfloat node380 = (node368 * 2.0);\n\tvec3 node258 = (vec3(((((gain(((ns_simplex3((vec3(node270, node367, node368) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node378, node379, node380) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5), ((((gain(((ns_simplex3((vec3(node270, node367, (node368 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node378, node379, (node380 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5), ((((gain(((ns_simplex3((vec3(node270, node367, (node368 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node378, node379, (node380 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5)) * 0.06);\n\tbool node250 = (node133 || ((Clone_1.idx == 4.0) && (node137_out0 > 0.5)));\n\tbool node254 = (!node250);\n\tvec3 node249_out0;\n\tif (node250) {\n\t\tnode249_out0 = vec3((node258.x * -1.0), node258.y, node258.z);\n\t} else {\n\t\tnode249_out0 = node258;\n\t}\n\tfloat node427 = (n11(node137_out0) * 0.25);\n\tvec2 node246 = rot2(node249_out0.xz, node427);\n\tfloat node471 = node124.x;\n\tfloat node472 = node124.y;\n\tfloat node473 = node124.z;\n\tvec3 node460 = (node124 + (vec3(((gain(((ns_simplex3((vec3(node471, node472, node473) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node471, node472, (node473 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node471, node472, (node473 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0)) * 0.1));\n\tfloat node515 = node200.x;\n\tfloat node516 = node200.y;\n\tfloat node517 = node200.z;\n\tvec3 node504 = (node200 + (vec3(((gain(((ns_simplex3((vec3(node515, node516, node517) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node515, node516, (node517 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node515, node516, (node517 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0)) * 0.1));\n\tfloat node448 = ((node67 + (((gain(((ns_simplex3((vec3(node460.x, node460.y, node460.z) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0) * 0.15)) + (((gain(((ns_simplex3((vec3(node504.x, node504.y, node504.z) / 1.5)) * 0.5) + 0.5), 3.0) * 2.0) - 1.0) * 0.0125));\n\tfloat node447 = (node45 + node448);\n\tvec4 node438 = vec4((0.5 + (node21 * mix(0.2, 0.8, n01(cos((((node447 + 0.5) * 3.141592653589793) * 2.0)))))), node447, 0.0, 0.0);\n\tvec2 node436 = vec2(node438.x, node438.y);\n\tvec3 node564 = vec3((node69 - (u_ty * 8.0)), node279, node297);\n\tfloat node580 = node564.x;\n\tfloat node581 = node564.y;\n\tfloat node582 = node564.z;\n\tfloat node592 = (node580 * 2.0);\n\tfloat node593 = (node581 * 2.0);\n\tfloat node594 = (node582 * 2.0);\n\tvec3 node563 = (node564 + (vec3(((((gain(((ns_simplex3((vec3(node580, node581, node582) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node592, node593, node594) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5), ((((gain(((ns_simplex3((vec3(node580, node581, (node582 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node592, node593, (node594 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5), ((((gain(((ns_simplex3((vec3(node580, node581, (node582 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node592, node593, (node594 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5)) * 0.1));\n\tfloat node562 = node563.x;\n\tfloat node637 = node563.y;\n\tfloat node638 = node563.z;\n\tfloat node648 = (node562 * 2.0);\n\tfloat node649 = (node637 * 2.0);\n\tfloat node650 = (node638 * 2.0);\n\tvec3 node550 = (vec3(((((gain(((ns_simplex3((vec3(node562, node637, node638) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node648, node649, node650) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5), ((((gain(((ns_simplex3((vec3(node562, node637, (node638 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node648, node649, (node650 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5), ((((gain(((ns_simplex3((vec3(node562, node637, (node638 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) + (((gain(((ns_simplex3((vec3(node648, node649, (node650 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5)) / 1.5)) * 0.06);\n\tvec3 node546_out0;\n\tif (node250) {\n\t\tnode546_out0 = vec3((node550.x * -1.0), node550.y, node550.z);\n\t} else {\n\t\tnode546_out0 = node550;\n\t}\n\tvec2 node543 = rot2(node546_out0.xz, node427);\n\tpos = (((((mix(((node10 + vec3(n11(node15.x), n11(node15.y), 0.0)) + vec3(node246.x, node249_out0.y, node246.y)), ((node10 + vec3(n11(node436.x), n11(node436.y), 0.0)) + vec3(node543.x, node546_out0.y, node543.y)), 1.0) * vec3((0.5625 / (u_resx / u_resy)), 1.0, 1.0)) * vec3(1.0, 1.0, 1.0)) * vec3(1.0, 1.0, 1.0)) * vec3(1.0, 0.8, 1.0)) + vec3(0.0, 0.06, 0.0));\n\talpha = mix(1.0, 1.0, 1.0);\n\tfloat node719 = mix(0.5, 1.0, 1.0);\n\tfloat node718 = clamp(node719, 0.0, 1.0);\n\tvec3 node734 = vec3(u_val3a, node82_out0, ((node132_out0 * 4.0) + 10.0));\n\tfloat node748 = node734.x;\n\tfloat node749 = node734.y;\n\tfloat node750 = node734.z;\n\tvec3 node733 = (node734 + (vec3(((gain(((ns_simplex3((vec3(node748, node749, node750) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node748, node749, (node750 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node748, node749, (node750 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0)) * 0.1));\n\tfloat node772 = gain(pow(node283, 8.0), 2.0);\n\tfloat node771 = (node772 * 0.5);\n\tfloat node774 = mix(1.0, 2.0, node772);\n\tfloat node808 = node734.x;\n\tfloat node809 = node734.y;\n\tfloat node810 = node734.z;\n\tvec3 node797 = (node734 + (vec3(((gain(((ns_simplex3((vec3(node808, node809, node810) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node808, node809, (node810 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node808, node809, (node810 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0)) * 0.1));\n\tweight = mix(mix(1.5, 3.0, (((node718 * (pow(((((gain(((ns_simplex3((vec3(node733.x, node733.y, node733.z) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0) * 0.5) + 0.5), 1.0) + node771)) * node774) * ((clamp(parabola(node65, 1.0), 0.0, 1.0) * 0.75) + 0.25))), mix(1.5, 3.0, (((node718 * (pow(((((gain(((ns_simplex3((vec3(node797.x, node797.y, node797.z) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0) * 0.5) + 0.5), 1.0) + node771)) * node774) * ((clamp(parabola(node448, 1.0), 0.0, 1.0) * 0.75) + 0.25))), 1.0);\n\tfloat node848 = float((u_val3a * 0.1));\n\tfloat node842 = (((ns_simplex2((vec2(node848, 0.0) / 1.5)) + (ns_simplex2((vec2((node848 * 2.0), 0.0) / 1.5)) * 0.5)) / 1.5) * 2.0);\n\tfloat node872 = ((node69 * ((ns_simplex2((vec2(float((node79 + 5.0)), 0.0) / 1.5)) * 0.5) + 0.5)) * 2.0);\n\tfloat node883 = (node283 * ((ns_simplex2((vec2(float((node79 + 15.0)), 0.0) / 1.5)) * 0.5) + 0.5));\n\tfloat node892 = ((((node132_out0 * ((ns_simplex2((vec2(float(node79), 0.0) / 1.5)) * 0.5) + 0.5)) * 2.0) + (u_val3a * 0.2)) + 10.0);\n\tvec3 node869 = vec3(((node872 - (node275 * 2.0)) + node883), node82_out0, node892);\n\tfloat node913 = node869.x;\n\tfloat node914 = node869.y;\n\tfloat node915 = node869.z;\n\tvec3 node868 = (node869 + (vec3(((gain(((ns_simplex3((vec3(node913, node914, node915) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node913, node914, (node915 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node913, node914, (node915 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0)) * 0.1));\n\tfloat node944 = node868.x;\n\tfloat node945 = node868.y;\n\tfloat node946 = node868.z;\n\tvec3 node867 = (node868 + (vec3(((gain(((ns_simplex3((vec3(node944, node945, node946) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node944, node945, (node946 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node944, node945, (node946 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0)) * 0.1));\n\tfloat node982 = (node69 * 2.0);\n\tfloat node983 = (node132_out0 * 3.0);\n\tvec3 node981 = vec3(node982, node983, 0.0);\n\tfloat node994 = node981.x;\n\tfloat node995 = node981.y;\n\tfloat node996 = node981.z;\n\tvec3 node980 = (node981 + (vec3(((gain(((ns_simplex3((vec3(node994, node995, node996) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node994, node995, (node996 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node994, node995, (node996 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0)) * 0.1));\n\tfloat node1017 = (-0.0825 * node772);\n\tvec3 node1037 = vec3(((node872 - (u_ty * 2.0)) + node883), node82_out0, node892);\n\tfloat node1051 = node1037.x;\n\tfloat node1052 = node1037.y;\n\tfloat node1053 = node1037.z;\n\tvec3 node1036 = (node1037 + (vec3(((gain(((ns_simplex3((vec3(node1051, node1052, node1053) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1051, node1052, (node1053 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1051, node1052, (node1053 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0)) * 0.1));\n\tfloat node1082 = node1036.x;\n\tfloat node1083 = node1036.y;\n\tfloat node1084 = node1036.z;\n\tvec3 node1035 = (node1036 + (vec3(((gain(((ns_simplex3((vec3(node1082, node1083, node1084) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1082, node1083, (node1084 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1082, node1083, (node1084 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0)) * 0.1));\n\tvec3 node1119 = vec3(node982, node983, 0.0);\n\tfloat node1130 = node1119.x;\n\tfloat node1131 = node1119.y;\n\tfloat node1132 = node1119.z;\n\tvec3 node1118 = (node1119 + (vec3(((gain(((ns_simplex3((vec3(node1130, node1131, node1132) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1130, node1131, (node1132 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1130, node1131, (node1132 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0)) * 0.1));\n\thue = mix(fract((((node842 + (((((gain(((ns_simplex3((vec3(node867.x, node867.y, node867.z) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0) * 0.5) + 0.5) * 0.33)) + ((((((gain(((ns_simplex3((vec3(node980.x, node980.y, node980.z) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5) + 0.5) * -1.0) * 0.1)) + node1017)), fract((((node842 + (((((gain(((ns_simplex3((vec3(node1035.x, node1035.y, node1035.z) / 1.5)) * 0.5) + 0.5), 1.0) * 2.0) - 1.0) * 0.5) + 0.5) * 0.33)) + ((((((gain(((ns_simplex3((vec3(node1118.x, node1118.y, node1118.z) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5) + 0.5) * -1.0) * 0.1)) + node1017)), 1.0);\n\tfloat node1173 = (node69 * 4.0);\n\tfloat node1175 = (node132_out0 + 20.0);\n\tvec3 node1171 = vec3((node1173 - (node275 * 4.0)), node82_out0, node1175);\n\tfloat node1186 = node1171.x;\n\tfloat node1187 = node1171.y;\n\tfloat node1188 = node1171.z;\n\tvec3 node1170 = (node1171 + (vec3(((gain(((ns_simplex3((vec3(node1186, node1187, node1188) / 1.5)) * 0.5) + 0.5), 1.5) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1186, node1187, (node1188 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 1.5) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1186, node1187, (node1188 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 1.5) * 2.0) - 1.0)) * 0.1));\n\tfloat node1209 = (1.0 - (node772 * 0.2));\n\tvec3 node1226 = vec3((node1173 - (u_ty * 4.0)), node82_out0, node1175);\n\tfloat node1239 = node1226.x;\n\tfloat node1240 = node1226.y;\n\tfloat node1241 = node1226.z;\n\tvec3 node1225 = (node1226 + (vec3(((gain(((ns_simplex3((vec3(node1239, node1240, node1241) / 1.5)) * 0.5) + 0.5), 1.5) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1239, node1240, (node1241 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 1.5) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1239, node1240, (node1241 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 1.5) * 2.0) - 1.0)) * 0.1));\n\tsat = mix(pow(pow(pow(((((gain(((ns_simplex3((vec3(node1170.x, node1170.y, node1170.z) / 1.5)) * 0.5) + 0.5), 1.5) * 2.0) - 1.0) * 0.5) + 0.5), 0.5), 1.5), node1209), pow(pow(pow(((((gain(((ns_simplex3((vec3(node1225.x, node1225.y, node1225.z) / 1.5)) * 0.5) + 0.5), 1.5) * 2.0) - 1.0) * 0.5) + 0.5), 0.5), 1.5), node1209), 1.0);\n\tfloat node1285 = ((node132_out0 + 10.0) + u_val3a);\n\tvec3 node1284 = vec3(node127, node82_out0, node1285);\n\tfloat node1297 = node1284.x;\n\tfloat node1298 = node1284.y;\n\tfloat node1299 = node1284.z;\n\tvec3 node1283 = (node1284 + (vec3(((gain(((ns_simplex3((vec3(node1297, node1298, node1299) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1297, node1298, (node1299 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1297, node1298, (node1299 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0)) * 0.1));\n\tvec3 node1339 = vec3(node127, node82_out0, node1285);\n\tfloat node1350 = node1339.x;\n\tfloat node1351 = node1339.y;\n\tfloat node1352 = node1339.z;\n\tvec3 node1338 = (node1339 + (vec3(((gain(((ns_simplex3((vec3(node1350, node1351, node1352) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1350, node1351, (node1352 + 33.333333333333336)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0), ((gain(((ns_simplex3((vec3(node1350, node1351, (node1352 + 66.66666666666667)) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0)) * 0.1));\n\tval = mix(((clamp(parabola(node65, 0.9), 0.0, 1.0) * (pow(((((gain(((ns_simplex3((vec3(node1283.x, node1283.y, node1283.z) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5) + 0.5), 2.0) * 1.75)) * node719), ((clamp(parabola(node448, 0.9), 0.0, 1.0) * (pow(((((gain(((ns_simplex3((vec3(node1338.x, node1338.y, node1338.z) / 1.5)) * 0.5) + 0.5), 2.0) * 2.0) - 1.0) * 0.5) + 0.5), 2.0) * 1.75)) * node719), 1.0);\n\t\n\n\n\tPData result;\n\tresult.p = pos;\n\tresult.w = weight;\n\tresult.hsv = vec3(hue, sat, val);\n\tresult.a = alpha;\n\tresult.extra_0 = extra_0;\n\treturn result;\n}\t\n\n\n\n\n\nvoid main()\n{\n\tPData pdata = draw();\n\n\tvec3 color = hsv2rgb(pdata.hsv);\n\tvec4 posw = vec4(pdata.p, pdata.w);\n\tvec4 colora = vec4(color, pdata.a);\n\n\tfragPos = posw;\n\tfragColor = colora;\n\n\t// if (mode == 0) gl_FragColor = posw;\n\t// if (mode == 1) gl_FragColor = colora;\n\t// if (MODE == 0) result = posw;\n\t// if (MODE == 1) result = colora;\n\t// if (MODE == 2) result = pdata.extra_0;\n\t// fragColor = result;\n}", "points": 66906, "primitives": []}